# SignalBigLab

### Требования к входным данным
#### для фотографий
- формат изображений .jpg
- разрешение фотографий не менее 512х512 
- отсутствие цветовой коррекции
- отсутствие ретуши
- отсутствие предварительного сжатия
- изображение резкое, без смазанных фрагментов, не шумное
- освещение искусственное, без засвеченных областей и теней по интенсивности сопоставимых с самими объектами
- фотографии сделаны под прямым углом к нормали поверхности с допущением небольшого отклонения до 10°
- многоугольник нарисован на отдельном листе чистой белой бумаги
- линии многоугольника нарисованы чёрным перманентным маркером толщиной 1-3мм

#### для предметов
- толщина объектов не менее 5 мм
- объекты полностью попадают в кадр
- объекты находятся в фокусе
- предметы не должны перекрывать друг друга
- между предметами должен быть зазор не менее 5 мм
- объекты не должны отбрасывать теней
- цвета предметов, присутствующих в кадре, должны быть контрастны относительно поверхности, на которой располагаются

#### для поверхности
- поверхность должна быть горизонтальная, ровная, без видимых дефектов 
- поверхность должна быть достаточного размера, чтобы предметы на ней помещались целиком
- поверхность должна быть однородной и однотонной

#### требования для датасета
- границы предметов должны четко выделяться на фоне белого листа бумаги
- каждый из выбранных предметов на фоне белого листа бумаги А4 должен попадать на фотографию целиком, так чтобы углы и края листа были видны и не перекрывались предметами

### Постановка задачи
На вход поступает фотография, на которой имеется некоторая выборка предметов и нарисованный маркером многоугольник. 

Необходимо понять, поместятся ли предметы внутрь многоугольника.

Объекты могут поместиться в многоугольнике, если при его наложении на совокупность предметов, никакая из сторон объектов не будет выходить за границы фигуры и при отсутвствии пересечения предметов.

### Требование к выходным данным
В качестве ответа на задачу, модуль должен вернуть один из возможных ответов (бинарная классификация)
- True, если предметы поместятся
- False, в противном случае
Для удобства, в случае, если расположение возможно, выводится картинка, показывающая его. Результат работы модуля выводится в консоль.

### План решения задачи

#### Примечание
Я строю алгоритм, который может найти решение для более общей задачи, это означает, что программа может работать с другим набором элементов с минимальными изменениями. Следовательно, я не буду использовать какую-либо информацию об элементе в алгоритме, а буду работать только проекциями реального мира на двумерную плоскость. Я получаю всю входную информацию из одной картинки, поэтому мне не нужно заботиться о размерах реального мира в сантиметрах или т. д. Все вычисления будут в относительных размерах или размерах пикселей.

#### Алгоритм

1. Сжать и бинаризовать изображение.    
 1.1 Сжатие изображения до размеров 512х512 (оХ сохраняет соотношение, если равномерно сжать не получится).    
 1.2 Поиск границ предметов с помощью детектора Кэнни.    
 1.3 Морфологическое закрытие.    
 1.4 Заливка контуров.    

2. Обнаружение объектов и многоугольника.    
2.1 Поиск контуров(cv.findContours) на бинаризованном изображении.    
2.2 Фильтрация и классификация найденных контуров.
2.2.1 Удаление вложенных контуров.    
2.2.2 Контур с максимальой площадью примем за полигон. Остальные за объекты.    

3. Поиск минимального ограничивающего прямоугольник (OBB) объектов и многоугольника.    

4. Создание набора текстур объектов размера OBB, который содержит соответствующие части бинаризованного изображения.
4.1 Проверка размеров объектов: не превышает ли один из размеров любого объекта размеры многоугольника.
4.2 Если предыдущее условие выполняется, выводим сообщение о провале. Иначе следуем дальше.

5. Создание полигональной текстуры, как текстуры объектов, но с инвертированной бинаризацией.    
Далее перенос и поворот текстуру объектов и добавление их к полигональной текстуре.    
Если возникает значение >1 в каком-то пикселе, то здесь объект сталкивается с границей многоугольника или другого объекта.    
Если этого не произошло, то рассматриваем следующий объект. Иначе - переходим к предыдущей версии текстуры и меняем расположение предыдущего объекта.    

6. Алгоритм размещения одного объекта выглядит следующим образом:     
6.1 Если коллизий между границами и объектами не выявлено, то переходим к следующему объекту (или сообщаем об успешном размещении, если это был последний объект).    
6.2 Иначе вращяем объект на 3 градуса, а затем смещаем текстуру объекта на значение, равное 5% от размера многоугольника по оси Х и У (вложенный цикл).     
6.3 Если по итогу всех перемещений расположить объекты не удалось, вращаем еще на один шаг.    
6.4 Если по итогу всех вращений расположить объекты не удалось, возвращаем False.    


### Набор исходных предметов
Набор предметов может быть найден [здесь](https://github.com/HellInsider/SignalBigLab/tree/develop/images)

### Датасет
Тестовый набор может быть найден [здесь](https://github.com/HellInsider/SignalBigLab/tree/develop/dataset)

### Пример работы программы    

1. Бинаризация ![image](https://github.com/HellInsider/SignalBigLab/blob/develop/results/binarization.jpg)    
2. Поиск предметов ![image](https://github.com/HellInsider/SignalBigLab/blob/develop/results/contours.jpg)    
3. Расположение предметов ![image](https://github.com/HellInsider/SignalBigLab/blob/develop/results/placement.jpg)    

